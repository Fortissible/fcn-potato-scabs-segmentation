# -*- coding: utf-8 -*-
"""TA_PCD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_s1wUgCHySuCVZFZynYRGmzbwbU5gU-f

# **LIBRARY, PACKAGE, FUNCTIONS**
"""

import numpy as np
import pandas as pd
import cv2 as cv
from skimage import io
from PIL import Image
import matplotlib.pylab as plt
import glob


def convert(image, rgb):
    row, col = np.array(image).shape
    canvas2 = np.zeros((row, col, 3), np.uint8)
    image_avg = int(np.average(image))
    print(image_avg)
    for i in range(0, row):
        for j in range(0, col):
            if image[i, j] >= image_avg+60:  # blue
                canvas2.itemset((i, j, 0), 255)
                canvas2.itemset((i, j, 1), 0)
                canvas2.itemset((i, j, 2), 255)
            else:
                canvas2[i, j] = rgb[i, j]
    return canvas2


def equalizeShowHistogram(gray):
    gray_arr = np.array(gray)
    plt.hist(gray.ravel(),255,[0,255])
    plt.show()
    #equ = cv.equalizeHist(gray)
    equ = (gray_arr - gray_arr.min())*255/(0-1)
    multiImage([gray,equ],["gray img", "equalized img"],1,2)
    return equ


def splitColor(img):
    hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
    lab = cv.cvtColor(img, cv.COLOR_BGR2Lab)
    blue, green, red = cv.split(img)
    l, a, b = cv.split(lab)
    h, s, v = cv.split(hsv)
    return blue, green, red, l, a, b, h, s, v


def multiImage(img_list, title_list, rows=3, columns=3, gray=True, idx=1, width=10, height=7):
    plt.rcParams["figure.figsize"] = [width, height]
    if (gray):
        for i in range(len(title_list)):
            plt.subplot(rows, columns, i + 1)
            plt.title(title_list[i] + "{}".format(idx + 1))
            plt.imshow(img_list[i], cmap='gray', vmin=0, vmax=255, interpolation='none')
            plt.axis('off')
    else:
        for i in range(len(title_list)):
            plt.subplot(rows, columns, i + 1)
            plt.title(title_list[i] + "{}".format(idx + 1))
            plt.imshow(img_list[i])
            plt.axis('off')
    plt.show()


def processingImage(image, choosed_ch, low_thresh=131, high_thresh=255):
    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)

    # tresholding citra pilihan "a"
    mask = cv.inRange(choosed_ch, low_thresh, high_thresh, cv.THRESH_BINARY)
    # cv2_imshow(mask)

    # mengaplikasikan filter median untuk menghilangkan noise2 disekitar tomat
    filter = cv.medianBlur(mask, 5)
    # cv2_imshow(filter)

    # melakukan dilatasi
    kernel = np.ones((9, 9), np.uint8)
    dilatasi = cv.dilate(filter, kernel, iterations=1)
    # cv2_imshow(dilatasi)

    # melakukan erosi
    kernel = np.ones((9, 9), np.uint8)
    erosi = cv.erode(dilatasi, kernel, iterations=1)
    # cv2_imshow(erosi)

    # melakukan closing
    closing = cv.morphologyEx(erosi, cv.MORPH_CLOSE, kernel)
    output = cv.bitwise_and(image, image, mask=closing)

    return mask, output


def histogram_equalization(gray):
    # segregate color streams
    gray_arr = np.array(gray)
    h_b, bin_b = np.histogram(gray_arr.flatten(), 256, [0, 256])
    plt.hist(gray_arr.ravel(), 255, [0, 255])
    plt.show()

    # calculate cdf
    cdf_b = np.cumsum(h_b)

    # mask all pixels with value=0 and replace it with mean of the pixel values
    cdf_m_b = np.ma.masked_equal(cdf_b, 0)
    cdf_m_b = (cdf_m_b - (cdf_m_b.min()+100)) * 255 / ((cdf_m_b.max()-55) - (cdf_m_b.min()+100))
    cdf_final_b = np.ma.filled(cdf_m_b, 0).astype('uint8')

    print(cdf_m_b.min(),cdf_m_b.max())
    # merge the images in the three channels
    img_b = cdf_final_b[b]

    img_out = img_b
    # print(equ)
    img_out = cv.normalize(img_out, dst=None, alpha=0, beta=500, norm_type=cv.NORM_MINMAX)
    img_out = cv.normalize(img_out, dst=None, alpha=0, beta=500, norm_type=cv.NORM_MINMAX)
    return img_out

def normalizeContrastGrayImage(intensity, lo_param=40, hi_param=40):
    minI = int(np.average(intensity)) - lo_param
    maxI = int(np.average(intensity)) + hi_param
    minO = 0
    maxO = 255
    iO = (np.array(intensity) - minI) * (((maxO - minO) / (maxI - minI)) + minO)
    return iO


"""# **PROSES**"""

images_path = glob.glob("PotatoInGas/rgb/rgb_test/*.png")
for i in range(len(images_path)):
    image = cv.imread(images_path[i])

    # cv2_imshow(image)
    blue, green, red, l, a, b, h, s, v = splitColor(image)
    title_list = ["Blue Channel", "Green Channel", "Red Channel",
                  "L Channel", "a Channel", "b Channel",
                  "H Channel", "S Channel", "V Channel"]
    #multiImage([blue, green, red, l, a, b, h, s, v], title_list, 3, 3, gray=True)

    # pilihan color channel untuk dijadikan mask
    choosed_ch = red

    # ---------------------------------------------------------

    # panggil fungsi untuk praproses image
    avg_ch_intensity = int(np.average(choosed_ch))
    print(avg_ch_intensity)
    mask, output = processingImage(image, choosed_ch, low_thresh=avg_ch_intensity, high_thresh=255)
    cv.imshow("out output", output)
    _, output_mask = cv.threshold(cv.cvtColor(output, cv.COLOR_BGR2GRAY), 1, 255, cv.THRESH_BINARY)

    # menampilkan dan menyimpan output
    image = cv.cvtColor(image, cv.COLOR_BGR2RGB)
    output2 = cv.cvtColor(output, cv.COLOR_BGR2RGB)
    img_list = [image, mask, output2]
    title_list = ["original img", "mask img", "background segmented"]
    # multiImage(img_list,title_list,1,3,gray=False)

    # ---------------------------------------------------------

    # split channel dari output
    blue, green, red, l, a, b, h, s, v = splitColor(output2)
    outEqu = histogram_equalization(s)
    outNorm = cv.normalize(s, dst=None, alpha=130, beta=200, norm_type=cv.NORM_MINMAX)

    title_list = ["Blue Channel", "Green Channel", "Red Channel",
                  "L Channel", "a Channel", "b Channel",
                  "H Channel", "S Channel", "V Channel"]
    #multiImage([blue, green, red, l, a, b, h, s, v], title_list, 3, 3, gray=True)
    cv.imshow("out S", s)
    print(np.average(b))
    _, kentang_mask = cv.threshold(b, int(np.average(b)), 255, cv.THRESH_BINARY)
    kentang_mask = cv.bitwise_not(kentang_mask)

    kernel = np.ones((9, 9), np.uint8)
    erosi = cv.erode(kentang_mask, kernel, iterations=1)
    dilatasi = cv.dilate(erosi, kernel, iterations=3)
    kentang_mask = cv.erode(dilatasi, kernel, iterations=4)
    cv.imshow("out kentang_mask", kentang_mask)

    hasilnya = cv.bitwise_and(outEqu,outEqu,mask=kentang_mask)
    cv.imshow("out hasilnya", hasilnya)

    test = convert(hasilnya, image)
    multiImage([image, test], ["input", "segmented output"], rows=1, columns=2,gray=False, idx=i + 1)
    cv.waitKey(0)
